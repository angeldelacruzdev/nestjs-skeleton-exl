import { ForbiddenException, Injectable, UnauthorizedException } from '@nestjs/common';
import { PrismaService } from '../prisma.service';
import * as bcrypt from 'bcrypt';
import { JwtService } from '@nestjs/jwt';
import { randomUUID } from 'crypto';
import { ActivityLogService } from '../activity-log/activity-log.service';

@Injectable()
export class AuthService {

    private readonly MAX_FAILED_ATTEMPTS = 5; // Intentos antes del bloqueo
    private readonly LOCK_TIME = 30 * 60 * 1000; // 30 minutos

    constructor(private prisma: PrismaService, private jwtService: JwtService, private activityLogService: ActivityLogService) { }

    /**
     * The `register` function asynchronously hashes the password and creates a new user with the provided
     * email and hashed password using Prisma.
     * @param {string} email - Email is a string that represents the user's email address.
     * @param {string} password - The `password` parameter in the `register` function is a string that
     * represents the user's password.
     * @returns The `register` function is returning a Promise that resolves to the result of creating a
     * new user in the database using Prisma. The user's email and hashed password are provided as data for
     * creating the user.
     */
    async register(email: string, password: string) {
        const hashedPassword = await bcrypt.hash(password, 10);
        return this.prisma.user.create({
            data: { email, password: hashedPassword },
        });
    }


    /**
     * The `login` function in TypeScript asynchronously authenticates a user by checking their email and
     * password, generating access and refresh tokens upon successful authentication.
     * @param {string} email - The `email` parameter in the `login` function is a string that represents
     * the email address of the user trying to log in.
     * @param {string} password - The `password` parameter in the `login` function is a string that
     * represents the user's password input during the login process.
     * @returns The `login` function returns an object with `accessToken` and `refreshToken` properties if
     * the login is successful. The `accessToken` is generated using `jwtService.sign` with a payload
     * containing the `userId` of the user and an expiration time of 15 minutes. The `refreshToken` is
     * generated by calling the `generateRefreshToken` method with the `user.id`. If there
     */
    async login(email: string, password: string, ipAddress?: string, userAgent?: string) {
        try {
            const user = await this.prisma.user.findUnique({ where: { email } });

            if (user?.lockedUntil && new Date() < user.lockedUntil) {
                throw new ForbiddenException('Tu cuenta está bloqueada. Inténtalo más tarde.');
            }

            if (!user || !(await bcrypt.compare(password, user.password))) {

                if (user) {
                    await this.activityLogService.createLog(user.id, 'FAILED_LOGIN', ipAddress, userAgent);
                    await this.registerFailedLogin(user.id, ipAddress, userAgent);
                }

                throw new UnauthorizedException('Credenciales inválidas');
            }

            await this.prisma.user.update({
                where: { id: user.id },
                data: { lockedUntil: null },
            });

            const accessToken = this.jwtService.sign({ userId: user.id }, { secret: process.env.JWT_SECRET, expiresIn: '15m' });
            const refreshToken = this.jwtService.sign({ userId: user?.id }, { secret: process.env.JWT_REFRESH_TOKEN_SECRET, expiresIn: '7d' });

            const refreshTokenHash = await bcrypt.hash(refreshToken, 12);

            await this.prisma.user.update({
                where: {
                    id: user.id
                },
                data: {
                    rtHash: refreshTokenHash
                },

            })


            const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // Expira en 7 días

            await this.prisma.refreshToken.create({
                data: {
                    token: refreshTokenHash,
                    userId: user.id,
                    expiresAt
                }
            })

            await this.activityLogService.createLog(user.id, 'LOGIN', ipAddress, userAgent);


            return { accessToken, refreshToken };

        } catch (error) {
            console.log(error)
        }
    }

    /**
     * The function `generateRefreshToken` generates a random token and stores it in the database with
     * an expiration date for a specific user.
     * @param {string} userId - The `userId` parameter in the `generateRefreshToken` function is a
     * string that represents the unique identifier of the user for whom the refresh token is being
     * generated.
     * @returns The `generateRefreshToken` function is returning the generated refresh token as a
     * string.
     */
    private async generateRefreshToken(userId: string) {
        try {
            const token = randomUUID();
            const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // Expira en 7 días

            await this.prisma.refreshToken.create({
                data: { userId, token, expiresAt },
            });

            return token;
        } catch (error) {
            console.log(error)
        }
    }

    /**
     * This TypeScript function refreshes an access token using a provided refresh token and returns a
     * new access token if the refresh token is valid.
     * @param {string} refreshToken - The `refreshToken` parameter is a string that represents the token
     * used to obtain a new access token after the original access token has expired. In the code snippet
     * you provided, the `refreshAccessToken` function takes a `refreshToken` as input and uses it to
     * generate a new access token for the
     * @returns The `refreshAccessToken` function is returning an object with a property `accessToken`
     * that contains the newly generated access token.
     */
    async refreshAccessToken(refreshToken: string, userId: string) {
        try {

            const findToken = await this.prisma.user.findFirst({
                where: { id: userId }
            });

            if (!findToken?.rtHash) {
                throw new UnauthorizedException();
            }

            const compareToken = await bcrypt.compare(refreshToken, `${findToken?.rtHash}`);

            if (!compareToken) {
                throw new UnauthorizedException();
            }


            const storedToken = await this.prisma.refreshToken.findUnique({
                where: { token: findToken?.rtHash },
            });

            if (!storedToken || storedToken.revoked || new Date() > storedToken.expiresAt) {
                throw new UnauthorizedException('Refresh token inválido');
            }

            const accessToken = this.jwtService.sign({ userId: findToken.id }, { secret: process.env.JWT_SECRET, expiresIn: '15m' });
            const newRefreshToken = this.jwtService.sign({ userId: findToken?.id }, { secret: process.env.JWT_REFRESH_TOKEN_SECRET, expiresIn: '7d' });


            const refreshTokenHash = await bcrypt.hash(refreshToken, 12);

            await this.prisma.user.update({
                where: {
                    id: findToken?.id
                },
                data: {
                    rtHash: refreshTokenHash
                },

            })
            return { accessToken: accessToken, refreshToken: newRefreshToken };
        } catch (error) {
            console.log(error)
        }
    }

    /**
     * The function `revokeRefreshToken` revokes a refresh token by updating its status to revoked in a
     * database using Prisma in TypeScript.
     * @param {string} refreshToken - A string representing the refresh token that needs to be revoked.
     */
    async revokeRefreshToken(refreshToken: string) {
        try {
            await this.prisma.refreshToken.update({
                where: { token: refreshToken },
                data: { revoked: true },
            });
        } catch (error) {
            console.log(error)
        }
    }

    private async registerFailedLogin(userId: string, ipAddress?: string, userAgent?: string) {
        await this.activityLogService.createLog(userId, 'FAILED_LOGIN', ipAddress, userAgent);

        const failedAttempts = await this.prisma.activityLog.count({
            where: {
                userId,
                action: 'FAILED_LOGIN',
                createdAt: { gte: new Date(Date.now() - 10 * 60 * 1000) }, // Últimos 10 min
            },
        });

        if (failedAttempts >= this.MAX_FAILED_ATTEMPTS) {
            await this.prisma.user.update({
                where: { id: userId },
                data: { lockedUntil: new Date(Date.now() + this.LOCK_TIME) },
            });

            await this.activityLogService.createLog(userId, 'ACCOUNT_LOCKED', ipAddress, userAgent);
        }
    }

    async getUserRolesAndPermissions(userId: string) {
        const user = await this.prisma.user.findUnique({
            where: { id: userId },
            select: {
                email: true,
                lockedUntil: true,
                roles: {
                    include: {
                        role: {
                            include: {
                                RolePermission: {
                                    include: {
                                        permission: true
                                    }
                                }
                            }
                        }
                    }
                }
            }

        });

        return user
    }




}
